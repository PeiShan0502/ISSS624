---
title: "Take-Home Exercise 1: Geospatial Analytics for Public Good"
author: "Kwok Pei Shan"
---

## Overview

Exploratory Spatial Data Analysis (ESDA) hold tremendous potential to address complex problems facing society. In this take-home exercise, we apply appropriate Local Indicators of Spatial Association (GLISA) and Emerging Hot Spot Analysis (EHSA) to undercover the spatial and spatio-temporal mobility patterns of public bus passengers in Singapore.

## Getting Started

In this take-home exercise, the following R packages will be used:

-   **sf** for geospatial data handling
-   **tidyverse** for non-spatial data handling
-   **tmap** for thematic mapping
-   **knitr** for creating html table.

```{r}
pacman::p_load(sf, sfdep, tidyverse, tmap, knitr)
```

## The Data

### Importing geospatial data

Firstly, we import *Bus Stops Location* from LTA DataMall. This provides information about all the bus stops currently being serviced by buses, including the bus stop code (identifier) and location coordinates:

```{r}
busstop <- st_read(dsn = "data/geospatial", 
                 layer = "BusStop") %>%
  st_transform(crs = 3414)
```

From the output, we can see that busstop is in SVY21 coordinates system. To learn more, we can apply *glimpse()* of **dplyr** package:

```{r}
glimpse(busstop)
```

From the above two outputs, we can see that there are 5161 points with 3 fields (BUS_STOP_N, BUS_ROOF_N, LOC_DESC).

### Importing aspatial data

Next, we will import *origin_destination_bus_202310.csv* into R by using *read_csv()* of **readr** package. The output is R data frame class. This data set returns the number of trips by weekdays and weekends from the origin to destination bus stops in October 2023:

```{r}
odbus <- read_csv("data/aspatial/origin_destination_bus_202310.csv", show_col_types = FALSE)
```

Similarly, we can use *glimpse()* to see all the columns and their data type in the R data frame:

```{r}
glimpse(odbus)
```

The fields **ORIGIN_PT_CODE** and **DESTINATION_PT_CODE** represent the bus stop number at the origin and destination. They need to be converted into factor data type so that we can geocode/georeference with the Bus Stops Location geospatial data later.

The code chunk below converts them into factor data type:

```{r}
odbus$ORIGIN_PT_CODE <- as.factor(odbus$ORIGIN_PT_CODE)
odbus$DESTINATION_PT_CODE <- as.factor(odbus$DESTINATION_PT_CODE) 
```

Now we check that both fields are in factor data type now:

```{r}
glimpse(odbus)
```

## **Task 1: Geovisualisation and Analysis**

With reference to the time intervals provided in the table below, we would like to compute the passenger trips generated by origin at the hexagon level.

| Peak hour period             | Bus tap on time (in 24hr format) |
|------------------------------|----------------------------------|
| Weekday morning peak         | 0600 to 0900                     |
| Weekday afternoon peak       | 1700 to 2000                     |
| Weekend/holiday morning peak | 1100 to 1400                     |
| Weekend/holiday evening peak | 1600 to 1900                     |

### Data Preparation

#### Filter by peak hour period

The output of the code chunks below shows the number of passenger trips for each bus stop in each peak hour period:

[Weekday morning peak: 6am to 9am]{.underline}

```{r}
origin6_9 <- odbus %>%
  filter(DAY_TYPE == "WEEKDAY") %>%
  filter(TIME_PER_HOUR >= 6 &
           TIME_PER_HOUR <= 9) %>%
  group_by(ORIGIN_PT_CODE) %>%
  summarise(TRIPS = sum(TOTAL_TRIPS))
```

[Weekday afternoon peak: 5pm to 8pm]{.underline}

```{r}
origin17_20 <- odbus %>%
  filter(DAY_TYPE == "WEEKDAY") %>%
  filter(TIME_PER_HOUR >= 17 &
           TIME_PER_HOUR <= 20) %>%
  group_by(ORIGIN_PT_CODE) %>%
  summarise(TRIPS = sum(TOTAL_TRIPS))
```

[Weekend/holiday morning peak: 11am to 2pm]{.underline}

```{r}
origin11_14 <- odbus %>%
  filter(DAY_TYPE == "WEEKENDS/HOLIDAY") %>%
  filter(TIME_PER_HOUR >= 11 &
           TIME_PER_HOUR <= 14) %>%
  group_by(ORIGIN_PT_CODE) %>%
  summarise(TRIPS = sum(TOTAL_TRIPS))
```

[Weekend/holiday evening peak: 4pm to 7pm]{.underline}

```{r}
origin16_19 <- odbus %>%
  filter(DAY_TYPE == "WEEKENDS/HOLIDAY") %>%
  filter(TIME_PER_HOUR >= 16 &
           TIME_PER_HOUR <= 19) %>%
  group_by(ORIGIN_PT_CODE) %>%
  summarise(TRIPS = sum(TOTAL_TRIPS))
```

We save the outputs in rds format for future use:

```{r}
write_rds(origin6_9, "data/rds/origin6_9.rds")
write_rds(origin17_20, "data/rds/origin17_20.rds")
write_rds(origin11_14, "data/rds/origin11_14.rds")
write_rds(origin16_19, "data/rds/origin16_19.rds")
```

#### Create Hexagon layer

[Create hexagon layer over Bus Stops Location:]{.underline}

The code chunk below is used to first create a hexagon layer over the *Bus Stops Location* (busstops), then find the number of bus stops in each hexagon. We also remove hexagons where there are no bus stops.

An explanation of key functions used:

-   `st_make_grid`: for hexagon, the argument cellsize refers to the distance between opposite edges. Since the task requires us to create a hexagon layer such that the perpendicular distance between the centre of the hexagon and its edges is 250m, this implies that the distance between opposite edges is 500m.

-   `st_sf`: convert **sfc_POLYGON** object (returned by `st_make_grid`) to simple feature **sf** object.

-   `st_intersects`: returns a list of which points are lying in each hexagon.

```{r}
area_honeycomb_grid = st_make_grid(busstop, c(500, 500), what = "polygons", square = FALSE)

# Convert to sf object
honeycomb_grid_sf = st_sf(area_honeycomb_grid) %>%
  # add grid ID (giving each hexagon a unique ID)
  mutate(grid_id = 1:length(lengths(area_honeycomb_grid)))

# count number of points (bus stops) in each grid/hexagon
honeycomb_grid_sf$n_colli = lengths(st_intersects(honeycomb_grid_sf, busstop))

# remove grid/hexagons with value of 0 (i.e. no points inside that grid)
honeycomb_count = filter(honeycomb_grid_sf, n_colli > 0)

#Note: The n_colli column shows the number of bus stops in each grid/hexagon.

```

```{r}
st_geometry(honeycomb_count)
```

We also confirm that the EPSG code for `honeycomb_count` is correct (3414 for projected coordinate system SVY21):

```{r}
st_crs(honeycomb_count)
```

### Geospatial Data Wrangling

#### Combining Bus Stop Location and Hexagon layer

The output of the code chunk below shows which bus stop is in which hexagon (BUS_STOP_N and grid_id) and the number of bus stops in that hexagon (n_colli).

```{r}
busstop_hex <- st_intersection(busstop, honeycomb_count) %>%
  select(BUS_STOP_N, grid_id, n_colli) %>%
  st_drop_geometry()

#BUS_STOP_N: Bus stop number
#n_colli: no. of bus stops in each hexagon
```

We save the output:

```{r}
write_rds(busstop_hex, "data/rds/busstop_hex.csv")
```

#### Join data frames to get number of trips in each hexagon

The output of the code chunk below shows the total number of passenger trips in each hexagon (for Weekday morning peak: 6am to 9am):

```{r}
hextrips6_9 <- left_join(origin6_9 , busstop_hex,
            by = c("ORIGIN_PT_CODE" = "BUS_STOP_N")) %>%
  group_by(grid_id) %>%
  summarise(TOT_TRIPS = sum(TRIPS))
```

Before continuing, it is good to check for duplicate records. The output of the code chunk below shows that there are no duplicate records:

```{r}
duplicate6_9 <- hextrips6_9 %>%
  group_by_all() %>%
  filter(n()>1) %>%
  ungroup()
```

If duplicated records are found, the code chunk below can be used to retain the unique records:

```{r}
unique_hextrips6_9 <- unique(hextrips6_9)
```

The code chunks below follow a similar process for the other peak periods:

[Weekday afternoon peak: 5pm to 8pm]{.underline}

```{r}
hextrips17_20 <- left_join(origin17_20 , busstop_hex,
            by = c("ORIGIN_PT_CODE" = "BUS_STOP_N")) %>%
  group_by(grid_id) %>%
  summarise(TOT_TRIPS = sum(TRIPS))

# Only take unique records:
unique_hextrips17_20 <- unique(hextrips17_20)
```

[Weekend/holiday morning peak: 11am to 2pm]{.underline}

```{r}
hextrips11_14 <- left_join(origin11_14 , busstop_hex,
            by = c("ORIGIN_PT_CODE" = "BUS_STOP_N")) %>%
  group_by(grid_id) %>%
  summarise(TOT_TRIPS = sum(TRIPS))

# Only take unique records:
unique_hextrips11_14 <- unique(hextrips11_14)
```

[Weekend/holiday evening peak: 4pm to 7pm]{.underline}

```{r}
hextrips16_19 <- left_join(origin16_19 , busstop_hex,
            by = c("ORIGIN_PT_CODE" = "BUS_STOP_N")) %>%
  group_by(grid_id) %>%
  summarise(TOT_TRIPS = sum(TRIPS))

# Only take unique records:
unique_hextrips16_19 <- unique(hextrips16_19)
```

#### Perform relational join with hexagon data to retain geometric information

The output of the code chunks below shows the following information for each peak hour period:

-   **grid_id**: the id for each hexagon

-   **n_colli**: the number of bus stops in each hexagon

-   **TOT_TRIPS**: the number of passenger trips in each hexagon

-   **area_honeycomb_grid**: geometric information of each hexagon

[Weekday morning peak: 6am to 9am]{.underline}

```{r}
hexData6_9 <- left_join(honeycomb_count, 
                            unique_hextrips6_9,
                            by = c("grid_id" = "grid_id"))
```

[Weekday afternoon peak: 5pm to 8pm]{.underline}

```{r}
hexData17_20 <- left_join(honeycomb_count, 
                            unique_hextrips17_20,
                            by = c("grid_id" = "grid_id"))
```

[Weekend/holiday morning peak: 11am to 2pm]{.underline}

```{r}
hexData11_14 <- left_join(honeycomb_count, 
                            unique_hextrips11_14,
                            by = c("grid_id" = "grid_id"))
```

[Weekend/holiday evening peak: 4pm to 7pm]{.underline}

```{r}
hexData16_19 <- left_join(honeycomb_count, 
                            unique_hextrips16_19,
                            by = c("grid_id" = "grid_id"))
```

|     |
|-----|
|     |

### Geospatial Visualisation

We would now like to display the geographical distribution of the passenger trips for each peak hour period:

[Weekday morning peak: 6am to 9am]{.underline}

```{r}
tm_shape(hexData6_9)+
  tm_fill("TOT_TRIPS", 
          style = "quantile", 
          palette = "Blues",
          title = "Passenger trips") +
  tm_layout(main.title = "Passenger trips generated at hexagon level on Weekday morning peak (6am to 9am)",
            main.title.position = "center",
            main.title.size = 0.7,
            legend.height = 0.45, 
            legend.width = 0.35,
            frame = TRUE) +
  tm_borders(alpha = 0.5) +
  tm_compass(type="8star", size = 2) +
  tm_scale_bar() +
  tm_grid(alpha =0.2)
```

[Weekday afternoon peak: 5pm to 8pm]{.underline}

```{r}
tm_shape(hexData17_20)+
  tm_fill("TOT_TRIPS", 
          style = "quantile", 
          palette = "Blues",
          title = "Passenger trips") +
  tm_layout(main.title = "Passenger trips generated at hexagon level on Weekday afternoon peak (5pm to 8pm)",
            main.title.position = "center",
            main.title.size = 0.7,
            legend.height = 0.45, 
            legend.width = 0.35,
            frame = TRUE) +
  tm_borders(alpha = 0.5) +
  tm_compass(type="8star", size = 2) +
  tm_scale_bar() +
  tm_grid(alpha =0.2)
```

[Weekend/holiday morning peak: 11am to 2pm]{.underline}

```{r}
tm_shape(hexData11_14)+
  tm_fill("TOT_TRIPS", 
          style = "quantile", 
          palette = "Blues",
          title = "Passenger trips") +
  tm_layout(main.title = "Passenger trips generated at hexagon level on Weekend morning peak (11am to 2pm)",
            main.title.position = "center",
            main.title.size = 0.7,
            legend.height = 0.45, 
            legend.width = 0.35,
            frame = TRUE) +
  tm_borders(alpha = 0.5) +
  tm_compass(type="8star", size = 2) +
  tm_scale_bar() +
  tm_grid(alpha =0.2)
```

[Weekend/holiday evening peak: 4pm to 7pm]{.underline}

```{r}
tm_shape(hexData16_19)+
  tm_fill("TOT_TRIPS", 
          style = "quantile", 
          palette = "Blues",
          title = "Passenger trips") +
  tm_layout(main.title = "Passenger trips generated at hexagon level on Weekday evening peak (4pm to 7pm)",
            main.title.position = "center",
            main.title.size = 0.7,
            legend.height = 0.45, 
            legend.width = 0.35,
            frame = TRUE) +
  tm_borders(alpha = 0.5) +
  tm_compass(type="8star", size = 2) +
  tm_scale_bar() +
  tm_grid(alpha =0.2)
```

## **Task 2: Local Indicators of Spatial Association (LISA) Analysis**

### Derive fixed distance spatial weights

Before we can derive the fixed distance weights, we need to determine the upper limit for distance band first.

[Weekday morning peak: 6am to 9am]{.underline}

```{r}
geo6_9 <- sf::st_geometry(hexData6_9)
nb6_9 <- st_knn(geo6_9, longlat = TRUE)
dists6_9 <- unlist(st_nb_dists(geo6_9, nb6_9))

# st_nb_dists() to calculate the nearest neighbour distance. The output is a list of distances for each observation's neighbour list.
```

```{r}
summary(dists6_9)
```

The summary statistics report above shows that the maximum nearest neighbour distance is 4272. Thus, we can use a threshold of 4300 to ensure that each area will have at least one neighbour.

We compute the fixed distance weights using the code chunk below:

```{r}
#| eval: false
wm_fd6_9 <- hexData6_9 %>%
  mutate(nb = st_dist_band(geo6_9,
                           upper = 4300),
               wt = st_weights(nb),
               .before = 1)

# st_dist_band() is used to identify neighbours based on a distance band (i.e., 4300). The output is a list of neighbours nb.

# st_weights() is then used to calculate polygon spatial weights of the nb list (default using row-standardised weights)
```

The code chunks below find a upper limit for distance band for the other peak periods:

[Weekday afternoon peak: 5pm to 8pm]{.underline}

```{r}
geo17_20 <- sf::st_geometry(hexData17_20)
nb17_20 <- st_knn(geo17_20, longlat = TRUE)
dists17_20 <- unlist(st_nb_dists(geo17_20, nb17_20))
```

```{r}
summary(dists17_20)
```

```{r}
#| eval: false
wm_fd17_20 <- hexData17_20 %>%
  mutate(nb = st_dist_band(geo17_20,
                           upper = 4300),
               wt = st_weights(nb),
               .before = 1)
```

[Weekend/holiday morning peak: 11am to 2pm]{.underline}

```{r}
geo11_14 <- sf::st_geometry(hexData11_14)
nb11_14 <- st_knn(geo11_14, longlat = TRUE)
dists11_14 <- unlist(st_nb_dists(geo11_14, nb11_14))
```

```{r}
summary(dists11_14)
```

```{r}
#| eval: false
wm_fd11_14 <- hexData11_14 %>%
  mutate(nb = st_dist_band(geo11_14,
                           upper = 4300),
               wt = st_weights(nb),
               .before = 1)
```

[Weekend/holiday evening peak: 4pm to 7pm]{.underline}

```{r}
geo16_19 <- sf::st_geometry(hexData16_19)
nb16_19 <- st_knn(geo16_19, longlat = TRUE)
dists16_19 <- unlist(st_nb_dists(geo16_19, nb16_19))
```

```{r}
summary(dists16_19)
```

```{r}
#| eval: false
wm_fd16_19 <- hexData16_19 %>%
  mutate(nb = st_dist_band(geo16_19,
                           upper = 4300),
               wt = st_weights(nb),
               .before = 1)
```

### Compute local Moran's I

[Weekday morning peak: 6am to 9am]{.underline}

```{r}
#| eval: false
lisa6_9 <- wm_fd6_9 %>%
  mutate(local_moran = local_moran(hexData6_9, nb, wt, nsim = 99),
         .before = 1) %>%
  unnest(local_moran)
```

[Weekday afternoon peak: 5pm to 8pm]{.underline}

```{r}
#| eval: false
lisa17_20 <- wm_fd17_20 %>%
  mutate(local_moran = local_moran(hexData17_20, nb, wt, nsim = 99),
         .before = 1) %>%
  unnest(local_moran)
```

[Weekend/holiday morning peak: 11am to 2pm]{.underline}

```{r}
#| eval: false
lisa11_14 <- wm_fd11_14 %>%
  mutate(local_moran = local_moran(hexData11_14, nb, wt, nsim = 99),
         .before = 1) %>%
  unnest(local_moran)
```

[Weekend/holiday evening peak: 4pm to 7pm]{.underline}

```{r}
#| eval: false
lisa16_19 <- wm_fd16_19 %>%
  mutate(local_moran = local_moran(hexData16_19, nb, wt, nsim = 99),
         .before = 1) %>%
  unnest(local_moran)
```

### Visualise local Moran's I

[Weekday morning peak: 6am to 9am]{.underline}

```{r}
#| eval: false
tmap_mode("plot")
tm_shape(lisa6_9) +
  tm_fill("ii") + 
  tm_borders(alpha = 0.5) +
  tm_view(set.zoom.limits = c(6,8)) +
  tm_layout(main.title = "local Moran's I of Weekday morning peak (6am to 9am)",
            main.title.size = 0.8)
```

[Weekday afternoon peak: 5pm to 8pm]{.underline}

```{r}
#| eval: false
tmap_mode("plot")
tm_shape(lisa17_20) +
  tm_fill("ii") + 
  tm_borders(alpha = 0.5) +
  tm_view(set.zoom.limits = c(6,8)) +
  tm_layout(main.title = "local Moran's I of Weekday afternoon peak (5pm to 8pm)",
            main.title.size = 0.8)
```

[Weekend/holiday morning peak: 11am to 2pm]{.underline}

```{r}
#| eval: false
tmap_mode("plot")
tm_shape(lisa11_14) +
  tm_fill("ii") + 
  tm_borders(alpha = 0.5) +
  tm_view(set.zoom.limits = c(6,8)) +
  tm_layout(main.title = "local Moran's I of Weekend/holiday morning peak (11am to 2pm)",
            main.title.size = 0.8)
```

[Weekend/holiday evening peak: 4pm to 7pm]{.underline}

```{r}
#| eval: false
tmap_mode("plot")
tm_shape(lisa16_19) +
  tm_fill("ii") + 
  tm_borders(alpha = 0.5) +
  tm_view(set.zoom.limits = c(6,8)) +
  tm_layout(main.title = "local Moran's I of Weekend/holiday evening peak (4pm to 7pm)",
            main.title.size = 0.8)
```

### Visualising LISA map

[Weekday morning peak: 6am to 9am]{.underline}

```{r}
#| eval: false
lisa_sig6_9 <- lisa6_9  %>%
  filter(p_ii_sim < 0.05)
tmap_mode("plot")
tm_shape(lisa6_9) +
  tm_polygons() +
  tm_borders(alpha = 0.5) +
tm_shape(lisa_sig6_9) +
  tm_fill("mean") + 
  tm_borders(alpha = 0.4)
```

[Weekday afternoon peak: 5pm to 8pm]{.underline}

```{r}
#| eval: false
lisa_sig17_20 <- lisa17_20  %>%
  filter(p_ii_sim < 0.05)
tmap_mode("plot")
tm_shape(lisa17_20) +
  tm_polygons() +
  tm_borders(alpha = 0.5) +
tm_shape(lisa_sig17_20) +
  tm_fill("mean") + 
  tm_borders(alpha = 0.4)
```

[Weekend/holiday morning peak: 11am to 2pm]{.underline}

```{r}
#| eval: false
lisa_sig11_14 <- lisa11_14  %>%
  filter(p_ii_sim < 0.05)
tmap_mode("plot")
tm_shape(lisa11_14) +
  tm_polygons() +
  tm_borders(alpha = 0.5) +
tm_shape(lisa_sig11_14) +
  tm_fill("mean") + 
  tm_borders(alpha = 0.4)
```

[Weekend/holiday evening peak: 4pm to 7pm]{.underline}

```{r}
#| eval: false
lisa_sig16_19 <- lisa16_19  %>%
  filter(p_ii_sim < 0.05)
tmap_mode("plot")
tm_shape(lisa16_19) +
  tm_polygons() +
  tm_borders(alpha = 0.5) +
tm_shape(lisa_sig16_19) +
  tm_fill("mean") + 
  tm_borders(alpha = 0.4)
```
